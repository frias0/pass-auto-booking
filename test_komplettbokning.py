# Generated by Selenium IDE
from calendar import weekday
from cmath import log
from datetime import date, datetime, timedelta
from lib2to3.pgen2 import driver
import logging
from multiprocessing.connection import wait
import queue
from signal import pause
import time
import json
import traceback
from selenium import webdriver
import selenium
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.support.ui import Select
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as ec
from selenium.common.exceptions import TimeoutException
import os
import sys
from selenium.webdriver.remote.webelement import WebElement



## email and phonenumber to send confirmation to, these are also needed to cancel/rebook an appointment
email = "your.email@gmail.com"
phone = "0701234567"

## If no input args (i.e find_specific_time())
## Specify the last datetime which is acceptable
last_date = datetime.fromisoformat("2022-09-25 22:00")


logging.basicConfig(
    format='%(asctime)s.%(msecs)03d %(levelname)-8s %(message)s',
    level=logging.INFO,
    datefmt='%Y-%m-%d %H:%M:%S')

class TestKomplettbokning():
  def setup_chrome(self):
    options: webdriver.ChromeOptions = webdriver.ChromeOptions()
    options.add_argument("--auto-open-devtools-for-tabs")
    options.add_argument("user-data-dir=./profileTest")
    options.add_argument("--install-url-blocklist-handlers")
    #options.add_argument("--headless")
    options.page_load_strategy = 'none'

    self.driver = webdriver.Chrome(options=options)

    ## email and phonenumber to send confirmation to, these are also needed to cancel/rebook an appointment
    self.email = "youremail@gmail.com"
    self.phone = "070123456"

    self.timer = time.time()
    self.stand_of_time = 30
    self.ban_time = 50
    self.count = 0
    self.queue = queue.Queue(6)
    self.vars = {}

## Inital setup session (agreement, how many, pass/id)
  def setup(self):
    try:
      self.wait = WebDriverWait(self.driver, timeout=99)
      self.driver.get("https://bokapass.nemoq.se/Booking/Booking/Index/stockholm")
      return self.parse_setup()
    except TimeoutException:
      self.driver.refresh()
    except Exception as e:
      logging.warning("failed setup: ")
      traceback.print_exc()
      if("timeout" in str(e)):
        return False
      input("Press enter to continue...")
      return False

  def parse_setup(self):
      time.sleep(5)
      breadcrumb = self.wait.until(ec.presence_of_element_located((By.CLASS_NAME, "breadcrumb")))
      if(breadcrumb is not None):
        lis = breadcrumb.find_elements(By.TAG_NAME, "li")
        if len(lis) == 0:
          self.driver.find_element(By.NAME, "StartNextButton").click()
          self.wait.until(ec.staleness_of(breadcrumb))
        elif "Avtal" in lis[len(lis)-1].text:
          self.driver.find_element(By.ID, "AcceptInformationStorage").click()
          select = Select(self.driver.find_element(By.ID, "NumberOfPeople"))
          select.select_by_value('2')
          # 5 | click | name=Next |
          self.driver.find_element(By.NAME, "Next").click()
          self.wait.until(ec.staleness_of(breadcrumb))
        elif "Boende" in lis[len(lis)-1].text:
          self.wait.until(ec.presence_of_element_located((By.XPATH,"/html/body/div[2]/div/div/div/form/div[1]/div[1]/div/label[1]")))
          self.driver.find_element(By.XPATH, "/html/body/div[2]/div/div/div/form/div[1]/div[1]/div/label[1]").click()
          self.driver.find_element(By.XPATH, "/html/body/div[2]/div/div/div/form/div[1]/div[2]/div/label[1]").click()
          # 7 | click | name=Next |
          self.driver.find_element(By.NAME, "Next").click()
          self.wait.until(ec.staleness_of(breadcrumb))
        elif len(self.driver.find_elements(By.NAME, "TimeSearchFirstAvailableButton")) != 0:
          return True
      return self.parse_setup()

## Scrape a single day, no rate limiting required (sleeping 1s anyway)
## returns true if appointment was secured
## i.e. you pressed book button fast enough, only email input and confirmation are left     
  def find_specific_time(self, required_date):
    time.sleep(1)
    self.count+=1
    logging.info(self.count)
    available_date_elm: WebElement = (self.wait.until(ec.presence_of_element_located((By.ID, "datepicker"))))
    date=str(required_date.isoformat())
    self.driver.execute_script("arguments[0].setAttribute(arguments[1],arguments[2])",available_date_elm, "value", date)
    available_date_elm.send_keys(Keys.ENTER)
    available_time_select = Select(self.driver.find_element(By.ID, "SearchTimeHour"))
    available_time_select.select_by_value("9")
    search_button = self.wait.until(ec.visibility_of_element_located((By.NAME, "TimeSearchButton")))
    search_button.click()
    self.wait.until(ec.staleness_of(search_button))
    book= self.wait.until(ec.presence_of_element_located((By.ID, "booking-next")))
    if(len(self.driver.find_elements(By.XPATH, "//*[@class='timetable-cells']")))>0:
      logging.info("Found time! \a")
      times = self.driver.find_elements(By.XPATH, "//*[@class='timetable-cells']")
      times[0].click()
      book.click()
      self.wait.until(ec.staleness_of(book))
      self.wait.until(ec.presence_of_element_located((By.CLASS_NAME, "breadcrumb")))
      if len(self.driver.find_elements(By.ID, "Customers_0__BookingFieldValues_0__Value")) == 0:
        return False
      return True
    return False

## Scrape "find next time" call, returns true if appointment was secured
## i.e. you pressed book fast enough, only email input and confirmation are left      
  def find_time(self):
    try:
      ## if rate limit is based on time between calls, or x calls/time, this can be used
      ## current theory is 2 calls/ minute
      ## thus stand_of_time is 30s (site can be so slow that you never get banned, so  )
      if(not self.queue.empty()):
        last = self.queue.get()
        now = time.time()
        since_last = now-last
        if(since_last<self.stand_of_time):
          sleep_time = self.stand_of_time - since_last
          if sleep_time > 0:
            logging.info("sleeping: " + str(sleep_time))
            time.sleep(sleep_time)
      available_date_elm = self.wait.until(ec.presence_of_element_located((By.ID, "datepicker")))
      search_button = self.wait.until(ec.presence_of_element_located((By.NAME, "TimeSearchFirstAvailableButton")))
      search_button.click()
      self.queue.put(time.time())
      self.wait.until(ec.staleness_of(available_date_elm))

      available_date_elm = self.wait.until(ec.presence_of_element_located((By.ID, "datepicker")))
      available_date_str = available_date_elm.get_attribute("value")
      available_time_str = Select(self.driver.find_element(By.ID, "SearchTimeHour")).first_selected_option.text
      available_date = datetime.fromisoformat(available_date_str+" "+available_time_str)

      ## Check if temp banned
      if len(self.driver.find_elements(By.XPATH, "//*[@class='validation-summary-errors alert alert-error']")) > 0:
        if "Du har gjort för många 'första lediga tid" in self.driver.find_element(By.XPATH, "//*[@class='validation-summary-errors alert alert-error']//li").text:
          #self.stand_of_time = self.stand_of_time*1.10
          logging.info("banned count/min: " + str(self.count/(self.ban_time/60)))
          if self.count == 0:
            self.ban_time = self.ban_time*1.20
            logging.info("Increasing ban_time to: " + str(self.ban_time))
          self.count=0
          if self.ban_time > 0:
            time.sleep(self.ban_time)
          return False
      else:
        self.count+=1

      logging.info(available_date.isoformat())

      if available_date < last_date and len(self.driver.find_elements(By.XPATH, "//*[@class='timetable-cells']")) >0:
        logging.info("Found time! \a")
        times = self.driver.find_elements(By.XPATH, "//*[@class='timetable-cells']")
        picked_time=0
        #while(picked_time<0):
        #  picked_time+=1
        times[picked_time].click()
        self.driver.find_element(By.ID, "booking-next").click()

        self.wait.until(ec.staleness_of(times[0]))
        self.wait.until(ec.presence_of_element_located((By.CLASS_NAME, "breadcrumb")))
        if len(self.driver.find_elements(By.ID, "Customers_0__BookingFieldValues_0__Value")) == 0:
          return False
        return True
      else:
        return False
    except TimeoutException:
      ## TODO restart if selenium wait times out (site can be super slow, or returned a 503 page) 
      ## this is supposed to restart the script, doesn't work
      os.execv(sys.argv[0], sys.argv)
    except Exception as e:
      logging.warning("failed find_time: " + str(e))
      traceback.print_exc()
      if("timeout" in str(e)):
        return False
      if("no such element:" in str(e)):
        return False
      input("\a\a\aPress enter to continue find...")
      return False

  def teardown(self):
    self.driver.quit()

## input email and confirm booking
  def test_komplettbokning(self):
    self.wait.until(ec.presence_of_element_located((By.ID, "Customers_0__BookingFieldValues_0__Value")))
    self.driver.find_element(By.ID, "Customers_0__BookingFieldValues_0__Value").click()
    # 12 | type | id=Customers_0__BookingFieldValues_0__Value | Filip
    self.driver.find_element(By.ID, "Customers_0__BookingFieldValues_0__Value").send_keys("Filip")
    # 13 | type | id=Customers_0__BookingFieldValues_1__Value | Asplund
    self.driver.find_element(By.ID, "Customers_0__BookingFieldValues_1__Value").send_keys("Asplund")
    # 14 | click | id=Customers_0__Services_0__IsSelected |
    self.driver.find_element(By.ID, "Customers_0__Services_1__IsSelected").click()
        # 14 | click | id=Customers_0__Services_0__IsSelected |
    self.driver.find_element(By.ID, "Customers_1__Services_0__IsSelected").click()
    self.driver.find_element(By.ID, "Customers_1__BookingFieldValues_0__Value").click()
    # 12 | type | id=Customers_0__BookingFieldValues_0__Value | Filip
    self.driver.find_element(By.ID, "Customers_1__BookingFieldValues_0__Value").send_keys("Anna")
    # 13 | type | id=Customers_0__BookingFieldValues_1__Value | Asplund
    self.driver.find_element(By.ID, "Customers_1__BookingFieldValues_1__Value").send_keys("Embrén")

    # 15 | click | name=Next |
    next= self.driver.find_element(By.NAME, "Next")
    time.sleep(5)
    next.click()
    # 16 | click | name=Next |
    self.wait.until(ec.staleness_of(next))
    next = self.wait.until(ec.presence_of_element_located((By.NAME, "Next")))
    time.sleep(5)
    next.click()
    self.wait.until(ec.staleness_of(next))
    # 17 | click | id=EmailAddress |
    self.driver.find_element(By.ID, "EmailAddress").click()
    # 18 | click | id=EmailAddress |
    self.driver.find_element(By.ID, "EmailAddress").click()
    # 19 | doubleClick | id=EmailAddress |
    element = self.driver.find_element(By.ID, "EmailAddress")
    actions = ActionChains(self.driver)
    actions.double_click(element).perform()
    # 20 | click | id=EmailAddress |
    self.driver.find_element(By.ID, "EmailAddress").click()
    # 21 | click | id=EmailAddress |
    self.driver.find_element(By.ID, "EmailAddress").click()
    # 22 | doubleClick | id=EmailAddress |
    element = self.driver.find_element(By.ID, "EmailAddress")
    actions = ActionChains(self.driver)
    actions.double_click(element).perform()
    # 23 | click | id=EmailAddress |
    self.driver.find_element(By.ID, "EmailAddress").click()
    # 24 | type | id=EmailAddress | email@gmail.com
    self.driver.find_element(By.ID, "EmailAddress").send_keys(self.email)
    # 25 | click | id=ConfirmEmailAddress |
    self.driver.find_element(By.ID, "ConfirmEmailAddress").click()
    # 26 | type | id=ConfirmEmailAddress | email@gmail.com
    self.driver.find_element(By.ID, "ConfirmEmailAddress").send_keys(self.email)
    # 27 | click | id=PhoneNumber |
    self.driver.find_element(By.ID, "PhoneNumber").click()
    # 28 | type | id=PhoneNumber | 070123455
    self.driver.find_element(By.ID, "PhoneNumber").send_keys(self.phone)
    # 29 | click | id=ConfirmPhoneNumber |
    self.driver.find_element(By.ID, "ConfirmPhoneNumber").click()
    # 30 | type | id=ConfirmPhoneNumber | 0763073421
    self.driver.find_element(By.ID, "ConfirmPhoneNumber").send_keys(self.phone)
    # 31 | click | id=SelectedContacts_0__IsSelected |
    self.driver.find_element(By.ID, "SelectedContacts_0__IsSelected").click()
    # 32 | click | id=SelectedContacts_1__IsSelected |
    self.driver.find_element(By.ID, "SelectedContacts_1__IsSelected").click()
    # 33 | click | id=SelectedContacts_2__IsSelected |
    self.driver.find_element(By.ID, "SelectedContacts_2__IsSelected").click()
    # 34 | click | id=SelectedContacts_3__IsSelected |
    self.driver.find_element(By.ID, "SelectedContacts_3__IsSelected").click()
    # 35 | click | name=Next |
    next = self.driver.find_element(By.NAME, "Next")
    time.sleep(5)
    next.click()
    # 36 | click | name=Next |
    self.wait.until(ec.staleness_of(next))
    time.sleep(5)
    self.driver.find_element(By.NAME, "Next").click()

test = TestKomplettbokning()

test.setup_chrome()

while(test.setup() == False):
  time.sleep(1)
  logging.info("try setup again")

today= date.today()
if(len(sys.argv) == 1):
  target_date = None
else:
  input_date = sys.argv[len(sys.argv)-1]
  if input_date == "tomorrow":
    target_date = today +timedelta(days=1)
  elif input_date == "sat":
    days_until_sat= 6 if today.weekday() == 7 else 5 - today.weekday()
    target_date = today + timedelta(days=days_until_sat)
logging.info("Trying to book on " + str(target_date))

## Start'a'spammin
if target_date is not None:
  while(test.find_specific_time(target_date) == False):
    time.sleep(1)
else:
  while(test.find_time() == False):
    time.sleep(1)

## Found a time, just confirm left
time.sleep(1)
test.test_komplettbokning()
input("Found time!!!\a\a\a\a\a")
#test.teardown()
